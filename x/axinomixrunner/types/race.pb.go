// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: axinomixrunner/axinomixrunner/race.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Race struct {
	Id                 uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	PlayerAddress      string `protobuf:"bytes,2,opt,name=playerAddress,proto3" json:"playerAddress,omitempty"`
	Bet                string `protobuf:"bytes,3,opt,name=bet,proto3" json:"bet,omitempty"`
	Mode               string `protobuf:"bytes,4,opt,name=mode,proto3" json:"mode,omitempty"`
	NeedToCollectCoins uint64 `protobuf:"varint,5,opt,name=needToCollectCoins,proto3" json:"needToCollectCoins,omitempty"`
	StartTime          uint64 `protobuf:"varint,6,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime            uint64 `protobuf:"varint,7,opt,name=endTime,proto3" json:"endTime,omitempty"`
	CoinsEarned        uint64 `protobuf:"varint,8,opt,name=coinsEarned,proto3" json:"coinsEarned,omitempty"`
	WinAmount          string `protobuf:"bytes,9,opt,name=winAmount,proto3" json:"winAmount,omitempty"`
	Score              uint64 `protobuf:"varint,10,opt,name=score,proto3" json:"score,omitempty"`
	State              string `protobuf:"bytes,11,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *Race) Reset()         { *m = Race{} }
func (m *Race) String() string { return proto.CompactTextString(m) }
func (*Race) ProtoMessage()    {}
func (*Race) Descriptor() ([]byte, []int) {
	return fileDescriptor_208fb1fbcd391512, []int{0}
}
func (m *Race) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Race) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Race.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Race) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Race.Merge(m, src)
}
func (m *Race) XXX_Size() int {
	return m.Size()
}
func (m *Race) XXX_DiscardUnknown() {
	xxx_messageInfo_Race.DiscardUnknown(m)
}

var xxx_messageInfo_Race proto.InternalMessageInfo

func (m *Race) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Race) GetPlayerAddress() string {
	if m != nil {
		return m.PlayerAddress
	}
	return ""
}

func (m *Race) GetBet() string {
	if m != nil {
		return m.Bet
	}
	return ""
}

func (m *Race) GetMode() string {
	if m != nil {
		return m.Mode
	}
	return ""
}

func (m *Race) GetNeedToCollectCoins() uint64 {
	if m != nil {
		return m.NeedToCollectCoins
	}
	return 0
}

func (m *Race) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Race) GetEndTime() uint64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *Race) GetCoinsEarned() uint64 {
	if m != nil {
		return m.CoinsEarned
	}
	return 0
}

func (m *Race) GetWinAmount() string {
	if m != nil {
		return m.WinAmount
	}
	return ""
}

func (m *Race) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *Race) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func init() {
	proto.RegisterType((*Race)(nil), "axinomixrunner.axinomixrunner.Race")
}

func init() {
	proto.RegisterFile("axinomixrunner/axinomixrunner/race.proto", fileDescriptor_208fb1fbcd391512)
}

var fileDescriptor_208fb1fbcd391512 = []byte{
	// 296 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0x41, 0x4e, 0x72, 0x31,
	0x10, 0xc7, 0xe9, 0xe3, 0x01, 0x1f, 0x43, 0x3e, 0x63, 0x26, 0x2e, 0xba, 0xd0, 0x86, 0x18, 0x63,
	0xd8, 0x88, 0x0b, 0x2f, 0x20, 0x12, 0x2f, 0x40, 0x58, 0xb9, 0x2b, 0xaf, 0xb3, 0x68, 0xc2, 0x6b,
	0x49, 0x5b, 0x22, 0xdc, 0xc2, 0xd3, 0x78, 0x06, 0x97, 0x2c, 0x5d, 0x1a, 0xb8, 0x88, 0x79, 0x83,
	0x04, 0x1f, 0x71, 0x37, 0xff, 0xdf, 0x6f, 0x3a, 0x6d, 0x3a, 0x30, 0xd0, 0x2b, 0xeb, 0x7c, 0x69,
	0x57, 0x61, 0xe9, 0x1c, 0x85, 0xfb, 0x93, 0x18, 0x74, 0x41, 0xc3, 0x45, 0xf0, 0xc9, 0xe3, 0x55,
	0x5d, 0x0d, 0xeb, 0xf1, 0xfa, 0x3d, 0x83, 0x7c, 0xa2, 0x0b, 0xc2, 0x33, 0xc8, 0xac, 0x91, 0xa2,
	0x2f, 0x06, 0xf9, 0x24, 0xb3, 0x06, 0x6f, 0xe0, 0xff, 0x62, 0xae, 0xd7, 0x14, 0x46, 0xc6, 0x04,
	0x8a, 0x51, 0x66, 0x7d, 0x31, 0xe8, 0x4e, 0xea, 0x10, 0xcf, 0xa1, 0x39, 0xa3, 0x24, 0x9b, 0xec,
	0xaa, 0x12, 0x11, 0xf2, 0xd2, 0x1b, 0x92, 0x39, 0x23, 0xae, 0x71, 0x08, 0xe8, 0x88, 0xcc, 0xd4,
	0x8f, 0xfd, 0x7c, 0x4e, 0x45, 0x1a, 0x7b, 0xeb, 0xa2, 0x6c, 0xf1, 0x5d, 0x7f, 0x18, 0xbc, 0x84,
	0x6e, 0x4c, 0x3a, 0xa4, 0xa9, 0x2d, 0x49, 0xb6, 0xb9, 0xed, 0x08, 0x50, 0x42, 0x87, 0x9c, 0x61,
	0xd7, 0x61, 0x77, 0x88, 0xd8, 0x87, 0x5e, 0x51, 0x0d, 0x78, 0xd6, 0xc1, 0x91, 0x91, 0xff, 0xd8,
	0xfe, 0x46, 0xd5, 0xe4, 0x57, 0xeb, 0x46, 0xa5, 0x5f, 0xba, 0x24, 0xbb, 0xfc, 0xc4, 0x23, 0xc0,
	0x0b, 0x68, 0xc5, 0xc2, 0x07, 0x92, 0xc0, 0x27, 0xf7, 0x81, 0x69, 0xd2, 0x89, 0x64, 0x8f, 0xfb,
	0xf7, 0xe1, 0xe9, 0xf1, 0x63, 0xab, 0xc4, 0x66, 0xab, 0xc4, 0xd7, 0x56, 0x89, 0xb7, 0x9d, 0x6a,
	0x6c, 0x76, 0xaa, 0xf1, 0xb9, 0x53, 0x8d, 0x97, 0xdb, 0xc3, 0x17, 0xdf, 0xfd, 0x6c, 0x63, 0x75,
	0xba, 0x9e, 0xb4, 0x5e, 0x50, 0x9c, 0xb5, 0x79, 0x41, 0x0f, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0xcb, 0xc6, 0x60, 0x5a, 0xcc, 0x01, 0x00, 0x00,
}

func (m *Race) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Race) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Race) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintRace(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Score != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x50
	}
	if len(m.WinAmount) > 0 {
		i -= len(m.WinAmount)
		copy(dAtA[i:], m.WinAmount)
		i = encodeVarintRace(dAtA, i, uint64(len(m.WinAmount)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CoinsEarned != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.CoinsEarned))
		i--
		dAtA[i] = 0x40
	}
	if m.EndTime != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x38
	}
	if m.StartTime != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x30
	}
	if m.NeedToCollectCoins != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.NeedToCollectCoins))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintRace(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Bet) > 0 {
		i -= len(m.Bet)
		copy(dAtA[i:], m.Bet)
		i = encodeVarintRace(dAtA, i, uint64(len(m.Bet)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PlayerAddress) > 0 {
		i -= len(m.PlayerAddress)
		copy(dAtA[i:], m.PlayerAddress)
		i = encodeVarintRace(dAtA, i, uint64(len(m.PlayerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRace(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRace(dAtA []byte, offset int, v uint64) int {
	offset -= sovRace(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Race) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRace(uint64(m.Id))
	}
	l = len(m.PlayerAddress)
	if l > 0 {
		n += 1 + l + sovRace(uint64(l))
	}
	l = len(m.Bet)
	if l > 0 {
		n += 1 + l + sovRace(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovRace(uint64(l))
	}
	if m.NeedToCollectCoins != 0 {
		n += 1 + sovRace(uint64(m.NeedToCollectCoins))
	}
	if m.StartTime != 0 {
		n += 1 + sovRace(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovRace(uint64(m.EndTime))
	}
	if m.CoinsEarned != 0 {
		n += 1 + sovRace(uint64(m.CoinsEarned))
	}
	l = len(m.WinAmount)
	if l > 0 {
		n += 1 + l + sovRace(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovRace(uint64(m.Score))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovRace(uint64(l))
	}
	return n
}

func sovRace(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRace(x uint64) (n int) {
	return sovRace(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Race) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRace
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Race: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Race: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRace
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRace
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRace
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRace
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRace
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRace
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedToCollectCoins", wireType)
			}
			m.NeedToCollectCoins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedToCollectCoins |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinsEarned", wireType)
			}
			m.CoinsEarned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoinsEarned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRace
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRace
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRace
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRace
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRace
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRace(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRace
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRace(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRace
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRace
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRace
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRace
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRace
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRace        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRace          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRace = fmt.Errorf("proto: unexpected end of group")
)
